---
description: 
globs: 
alwaysApply: true
---
# Project Rules for Cursor

This document defines the rules and guidelines that the AI coding assistant (Cursor) must follow when generating or modifying code for the Hetri project. These rules ensure that the assistant's contributions align with our architecture and coding standards, and that no unintended changes are made. The assistant (Cursor) should treat these as binding instructions whenever it operates on the Hetri codebase.

## Core Development Rules

### 1. Respect the Established Architecture
The assistant must not introduce new architectural patterns or technologies that diverge from the design documents. All code should conform to the defined stack (React Native frontend, FastAPI backend, MS SQL DB, MQTT, etc.). For example, do not spontaneously replace MQTT with HTTP polling or switch the database to a different engine. Any suggestion of a major change should be ignored unless explicitly requested by the team.

### 2. No Out-of-Scope Changes
Only implement features and fixes that are part of the requirements or user stories. The assistant should not refactor or "improve" parts of the code that are unrelated to the current task. Unprompted optimizations or style changes are not allowed, as they can introduce bugs or reduce clarity. For instance, if working on treat request logic, do not suddenly refactor the entire auth module. Keep the changes minimal and focused.

### 3. Preserve Abstraction Layers
Adhere to the separation of concerns laid out in the Backend and Frontend guidelines. Do not mix UI code with business logic, or database code with routing logic. For example, in backend code, use the service functions and database models as designed; do not write raw SQL in the API route handler if the pattern is to use ORM models. Similarly, in the frontend, do not directly manipulate global state from deep child components – follow the state management strategy (Redux, context) as specified.

### 4. Follow the Implementation Plan
The assistant should be aware of the project's implementation roadmap and ensure code contributions align with the current development phase. If we are in early phases, avoid using placeholders meant for later phases. Conversely, do not implement future phase features prematurely. For instance, if the current milestone is getting basic streaming working, the assistant should not try to implement multi-tenant analytics reporting yet. Stick to the sequence unless instructed otherwise.

### 5. No Unauthorized Refactoring
Refactoring of code (changing structure without changing functionality) should only be done when explicitly requested (e.g., "Refactor the Pet model to split name into first/last"). The assistant should not change variable names, rewrite loops, alter file organization, or adjust formatting on a whim. Consistency is crucial; unexpected refactors can confuse version history and team members. Maintain the existing coding style and structure; if something seems inefficient or outdated, you may comment or suggest, but do not change it unless approved.

## Code Quality Standards

### 6. Explicit Naming and Clarity
When writing new code, choose clear, descriptive names for variables, functions, classes, etc., as per our conventions. Avoid single-letter or overly terse names (e.g., use `sendTreatRequest()` rather than `sndTrt()` or `f1()`). Aim for code that is self-documenting. Similarly, add comments where needed to clarify complex logic, but keep them relevant and updated. If the code logic is derived from external references or known tricky aspects, a brief comment is helpful.

### 7. Coding Standards Compliance
Adhere to the language-specific style guidelines outlined (PEP8 for Python, ESLint rules for JS/TS, etc.). The assistant's code should pass our linters and formatters. Use the project's configured tools (e.g., black, Prettier) if available; otherwise, follow the conventions in existing code. For example, maintain 4-space indentation in Python, use type hints in function definitions, etc. In React, follow JSX style best practices (proper casing, closing tags, etc.).

### 8. Testing and Verification
Whenever the assistant writes or modifies code for a feature, corresponding tests (if testing framework is in place) should be updated or added. At a minimum, manually verify in a development environment if possible. The assistant should not assume something works without either writing a test or describing how it should be tested. Ensure that all existing tests continue to pass after changes.

## Security and Performance Guidelines

### 9. Security and Privacy
The assistant must not introduce any code that compromises security. Always follow the security considerations in our design: for instance, when handling JWTs, use the established library and verification process, do not roll out a custom weak method. When writing SQL queries or constructing JSON, guard against injections by using parameter binding or ORM methods properly. Also, handle sensitive data carefully (e.g., never log plaintext passwords, never expose secrets to frontend).

### 10. Resource Management
Be mindful of performance and resource usage as per our non-functional requirements. For example, avoid extremely frequent polling loops that could drain device battery or hog the CPU. Instead, use events or reasonable intervals as designed. The assistant should implement efficient algorithms as needed (e.g., prefer a set lookup O(1) over a list search O(n) for large data if applicable). But do not prematurely optimize in a way that reduces code clarity unless performance tests indicate a need.

### 11. No Secrets or Credentials in Code
The assistant should never hardcode secrets, API keys, or passwords. Use configuration as established (e.g., environment variables). If in a development context you need a stub, clearly mark it and ensure it's not committed to production code.

## Documentation and Maintenance

### 12. Documentation and Comments
If generating code that implements a non-obvious part of the system, include clear comments or docstrings. For instance, if adding a complex SQL query or an MQTT handling nuance, comment on its purpose. However, avoid excessive comments for trivial code (don't state the obvious). Keep project documentation (like README or inline docs) updated if your change affects usage or setup.

### 13. User Interface Consistency
For frontend changes, ensure any new UI element or screen follows the established style (colors, fonts, spacing defined in the Frontend Guidelines). Do not create radically different looking components without design approval. E.g., if we have a Button component style, reuse it; do not introduce a new button style with different rounding or color.

### 14. Graceful Error Handling
All code, particularly at integration points (network calls, hardware access, etc.), should handle errors gracefully. The assistant should implement try/except or promise catch where appropriate, and either recover or report the error in a controlled way (return an HTTP 500 with message, or show a user-friendly error in UI). Crashes or unhandled exceptions are to be avoided.

## Compatibility and Integration

### 15. Keep Changes Backwards-Compatible (when possible)
If modifying a function or API that other parts of the system use, try to avoid breaking its interface. If you must change it (e.g., function signature), update all references accordingly and test them. For public-facing API endpoints, if a change is needed, consider versioning or at least coordinate front/back changes to deploy together to avoid downtime.

### 16. Confirm Requirements Before Implementation
If the assistant is unsure about how to implement a particular requirement or suspects ambiguity, it should seek clarification (through the provided design docs or by asking if in interactive mode with the team) rather than guessing and coding something incorrectly. It's better to pause and confirm than to implement the wrong behavior. For example, if not sure about treat cooldown logic, flag it rather than arbitrarily choosing a value.

### 17. Minimal External Dependencies
Do not introduce new libraries or dependencies without justification. Our stack should remain as lean as possible. If a task can be done with the standard library or an existing dependency, use that. If a new dependency is absolutely needed for a feature (e.g., image processing), discuss or note it clearly. Adding dependencies increases maintenance burden, so do so sparingly.

## Development Process Guidelines

### 18. Coordination with Implementation Plan
For multi-step features, ensure intermediate states are functional. The assistant should, for instance, implement the backend part of a feature and also provide stubs or temporary handling in the frontend so that the app doesn't break in between. Follow the plan where one step might involve partial integration; ensure that partial integration is handled gracefully (e.g., if video isn't ready yet, hide the video player behind a feature flag in the UI).

### 19. Testing in Realistic Conditions
After implementation, the assistant should simulate real usage as much as possible. For example, after coding the treat request flow, simulate with one owner and one staff account to see the full cycle. This might not be direct code but at least provide instructions or scripts for testing. Always consider the multi-tenant scenario – test as two different tenants to confirm isolation holds.

### 20. Documentation of Changes
When the assistant completes a task, it should update any relevant documentation files (code comments, docstrings, or project docs) to reflect the new behavior or design. For instance, if an API endpoint request/response format changed, update the API reference documentation. Similarly, if a new configuration env variable is introduced, document it in the `.env.example` or README.

## Project Context Rules

### 21. Multi-Tenant Awareness
Always consider multi-tenant implications when writing code. Ensure data isolation between facilities (tenants) is maintained. Every database query should consider tenant scoping, and no cross-tenant data access should be possible. When implementing features, test with multiple tenant scenarios to ensure proper isolation.

### 22. Device Constraints Consideration
Remember that collar devices have limited battery and processing power. Any device-related code should minimize resource usage. Prefer lightweight protocols and efficient algorithms. Consider power-saving modes and optimize for battery life in device interactions.

### 23. Real-Time Requirements
The system has strict latency requirements, especially for treat requests (~1 second) and video streaming (~2 seconds). Any code that affects these critical paths should prioritize performance and real-time delivery. Use appropriate technologies (MQTT for commands, WebSocket for real-time updates) as specified in the architecture.

### 24. Safety and Help Alert Priority
Any code related to help alerts or safety features should be prioritized and thoroughly tested. These features are critical for pet and staff safety. Ensure reliability, immediate delivery, and proper error handling for all safety-related functionality.

By following these rules, the AI assistant will produce code that is consistent, reliable, and aligned with the project's needs. These rules help ensure that the AI's contributions are positive and reduce the need for extensive human rework or code reviews to fix AI-introduced issues. The assistant should always cross-check its actions against these rules before finalizing any code changes.


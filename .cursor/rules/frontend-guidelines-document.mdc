---
description: 
globs: 
alwaysApply: true
---
# Frontend Guidelines Document

This document outlines the principles and conventions for developing the Hetri mobile frontend (and any web frontend, if applicable) using React Native. By following these guidelines, we ensure a consistent, maintainable, and user-friendly interface across our app for PAW Parents and PAW Admins. The aim is to make development efficient and the UX intuitive, even as we add features.

## Architectural Principles

* **Single Codebase, Multiple Roles:** We maintain one React Native codebase that serves both pet owners (clients) and facility staff (admins). Use role-based rendering to tailor the experience. For example, after authentication, check the user's role from the JWT or user store, and direct them to either the OwnerStack or AdminStack navigator. This avoids duplicating code for two separate apps – most components and logic can be reused with conditional behaviors.

* **Separation of Concerns:** Keep presentation, state management, and business logic distinct. UI components (especially dumb components) should focus on rendering data given via props. Business logic (e.g., form validation, reacting to WebSocket events) can reside in controller hooks or Redux thunks/sagas. This separation makes components more reusable and easier to test. For instance, a `PetCard` component simply displays pet info and triggers a callback when clicked, whereas the logic to fetch pet data from API lives in a Redux action or a useEffect in a screen component.

* **Abstraction for API calls:** Implement a layer for API interaction (e.g., a module with functions like `api.login()`, `api.requestTreat(petId)`). This way, components or Redux actions call these functions instead of using `fetch`/Axios all over. It centralizes error handling and authentication token injection. Also, abstracting WebSocket event handling (e.g., a single service that connects and distributes messages to the relevant parts of app) will keep components cleaner.

* **Consistency with Design System:** Adhere to a consistent design system for colors, fonts, and spacing. Define a theme (either using React Native Paper's theming or a custom ThemeContext) that includes our brand colors (e.g., primary, secondary, accent for the TreatTap action, etc.), font sizes, and common styles (rounded corners on cards, shadows on modals, etc.). Use these consistently so the app looks cohesive.

## State Management and Data Flow

* **Redux State Structure:** Structure the Redux store by feature domains. For example:
  * `auth`: stores current user, token, and login status.
  * `pets`: stores pet profiles and maybe current pet's status.
  * `treatRequests`: (for admin) stores list of pending treat requests.
  * `devices`: (for admin) stores device status info like battery for each.
  
  Each slice can have its own reducer and actions (using Redux Toolkit's createSlice to reduce boilerplate). This modular approach ensures we only rerender components when necessary and makes it easier to reason about state updates.

* **Using Redux Toolkit Query or Sagas:** For data fetching, consider using RTK Query which can automatically manage caching of API results and update components when data changes. For example, an owner's app could use a `useGetPetStatusQuery(petId)` hook to fetch current pet status and automatically refresh it. Alternatively, use **Redux-Saga** for more complex asynchronous flows (like listening to WebSocket events and dispatching actions). Sagas could handle side effects, e.g., when a treat delivered message comes in via WebSocket, a saga catches it and dispatches an action to update the `treatRequests` state and maybe show a toast notification.

* **Local Component State vs Global:** Use local `useState` for UI-only state that doesn't need to be global (e.g., whether a dropdown is open, current text in an input before submission). Use global state for things that must be accessed by multiple components or reflect system state (e.g., logged-in user info, the list of dogs currently online which multiple screens might need). Lean toward keeping state minimal and only as global as necessary. Overuse of global state can make the app sluggish and complex.

* **Immutable Updates and Pure Functions:** When updating state (especially Redux), do not mutate. Redux Toolkit allows mutations via its createSlice (using Immer under the hood), which is fine – use that pattern instead of directly altering state in place. For context or any plain React state, treat them immutably too (e.g., use spread operator to create new objects/arrays when needed) to avoid unexpected bugs. Pure functions (no side effects) should be used for reducers/selectors to keep state logic predictable.

## Component Structure and Hierarchy

* **Component Types:**
  * **Screens**: Top-level components tied to routes (via React Navigation). They assemble one or more child components to form a full screen (e.g., `LiveStreamScreen`, `AdminDashboardScreen`). Screens may connect to Redux or context to retrieve data and pass to child components. Keep screens relatively light – they can coordinate data fetching (like dispatch a Redux action in useEffect to load initial data) and handle user interactions at a high level, but delegate the actual display to UI components.
  * **Presentational Components:** These focus purely on UI, receiving props and rendering them. E.g., `PetCameraView` (shows video player and a treat button), `TreatRequestItem` (shows one treat request with pet name and time), `BatteryIndicator` (icon with battery level). Presentational components should be reusable and not directly know about Redux or business logic; they just call callbacks or show given data.
  * **Containers (if needed):** In cases where multiple presentational components need to be composed with logic, you can have container components. With hooks, often the screen itself acts as container. But for example, if you need a component that is used in multiple places and needs to connect to Redux to get data, you could create a container version. However, best practice with RN hooks is to use the hooks in the screens and pass data down, rather than deep nesting connect() HOCs.

* **Component Hierarchy Example (Owner Flow):**
  * `OwnerHomeScreen` – uses `useSelector` to get pet info, renders `LiveVideoCard` and maybe `ActivitySummary`.
    * `LiveVideoCard` – presentational, given props like `videoUrl` and a callback `onTreatPress`. Contains the video player and treat button.
    * `ActivitySummary` – presentational, shows last known activity or a small chart.
  * When the owner navigates to full screen video: `LiveStreamScreen` – might reuse `LiveVideoCard` or have its own layout with video player and more controls.

* **Naming Conventions:**
  * Use **PascalCase** for component filenames and component names (e.g., `LiveVideoCard.tsx` exporting component `LiveVideoCard`).
  * Use **camelCase** for variables, functions, and object keys. Constants can be UPPER_SNAKE_CASE if they are truly global constants (though in JS, module-scope `const` variables suffice).
  * Prefix custom hooks with `use` (e.g., `useAuth()` for an authentication hook).
  * Group related components in a folder. For example, under `components/` have subfolders like `Pet/` for pet-related components (PetCard, PetList, PetDetails…), `Admin/` for admin components (TreatRequestItem, DeviceStatusBadge, etc.). This organization helps quickly find components and promotes modularity.

* **File/Folder Structure:**
  * `/src` (if using a src directory pattern) or root of project:
    * `components/` – reusable components across screens. Could further categorize as mentioned.
    * `screens/` – each screen in a subfolder or file. e.g., `OwnerHomeScreen.tsx`, `AdminDashboardScreen.tsx`. If screens share subcomponents only used by that screen, you can nest a `components/` inside a screen folder.
    * `navigation/` – define the navigators (Stack, Tab configurations for Owner and Admin). For example, `OwnerNavigator.tsx` defines all screens for owners, their options, etc.
    * `store/` – Redux store setup, slices. e.g., `store/index.ts` for configuring store, `store/petsSlice.ts`, `store/authSlice.ts` etc.
    * `api/` – API client code. Possibly subdivide if many endpoints (authApi.ts, petApi.ts). If using RTK Query, this might not be needed as it co-locates in slices.
    * `utils/` – utility functions (date formatters, etc.).
    * `assets/` – images, fonts, etc.
    
  This structure keeps things logical. When adding new features, developers know where to add new screens vs new components.

## Styling and UX Considerations

* **Styling approach:** Use **StyleSheet.create** for defining styles, or styled-components if preferred by team. We need consistent spacing and sizing, which we can enforce through a design system. E.g., define constants for base unit (like 8px increments), and ensure margins/padding use those. Use flexbox for layout – RN's flexbox makes it easier to adapt to different screen sizes. We'll design primarily for typical phone sizes (~5.5-6.5 inch screens) but also ensure it doesn't break on larger tablets (perhaps by using percentage widths or max widths for content on very large screens).

* **Colors and Emphasis:** Follow the **Von Restorff effect** to highlight key actions. For instance, our color palette might be largely neutral/blues for general UI, but the **TreatTap button** should be a standout color (say orange or green) not used elsewhere prominently, so it draws the eye. Only one primary action per screen should have the standout treatment. Other actions (secondary buttons) use the secondary or grey style.

* **Touchable Feedback:** All interactive elements (buttons, list items, icons that act like buttons) should use RN's `Pressable` or `TouchableOpacity` with a visible feedback (opacity or ripple). This ensures users know their tap was registered. For critical actions (like "End Session" or admin's "Send Help Alert"), use a confirmation dialog to prevent accidental activation.

* **Navigation & Back:** Use a consistent navigation scheme – if using a stack navigator, ensure a back button is shown (automatically provided by React Navigation on iOS, and a top-left arrow on Android). For modal screens, perhaps provide a cancel button. Users should never feel "stuck". In the admin flows, where there might be deeper nested screens (e.g., Admin Dashboard -> Pet Detail -> Device Detail), ensure the hierarchy is clear and back navigations work as expected.

* **Forms and Validation:** For any forms (login, adding a pet, etc.), use controlled components for inputs and provide immediate validation feedback. E.g., if an email is improperly formatted, show a small red text below the field as soon as the field loses focus. Use libraries like Formik or React Hook Form if forms become complex. Ensure the submit button is clearly enabled only when form is ready or handle errors gracefully (e.g., shake the form and show error if user tries to submit incomplete info).

* **Accessibility:** We aim to follow accessibility best practices: use accessible roles (`accessible={true}`, `accessibilityLabel` on components like icons so screen readers know what they are), ensure color contrast is sufficient (our highlight color vs background should be high contrast for visibility). Use scalable font sizes or allow the OS font scaling where possible so users who increased text size can still read content. While our user base might not heavily rely on screen readers, it's good practice to label key buttons (like TreatTap should have an accessibilityLabel "Send Treat request").

* **Testing UI:** We will test the app on both platforms. Use emulators and at least one physical device if possible for camera and performance tests. Identify and fix any platform-specific UI issues (React Native covers most, but differences in font rendering or video player behavior might arise). Also test flows such as backgrounding the app and coming back (the WebSocket should reconnect, etc.).

## Coding Conventions

* **Naming & Coding Style:** As mentioned, PascalCase for components, camelCase for variables. Write self-explanatory names: prefer `requestTreat` over `reqTrt`. The code should be readable like prose. We adopt a linter configuration (ESLint with Airbnb or similar rules, and Prettier for formatting). This enforces things like semi-colon usage, quotes, etc. The repository will have a pre-commit hook (using Husky) to run Prettier/ESLint so that all code committed adheres to the style.

* **Comments and Documentation:** Use comments sparingly but effectively. For complex chunks of logic, add a comment block to explain intent (e.g., `// This effect subscribes to WebSocket events and dispatches appropriate actions`). For functions, if their purpose isn't immediately obvious, a one-line JSDoc comment can help. For example, a utility like `formatTime()` can have `/** Converts seconds to mm:ss format */`. In general, prefer clear code over excessive comments – but ensure that any workaround or hack is well-commented with a TODO if needed.

* **Git Practices:** Each feature or bugfix on a new branch; commit messages should be descriptive ("Add treat request handler in AdminDashboard" rather than "update code"). We avoid committing commented-out code or leaving `console.log` in production. Debugging logs can be wrapped in some debug flag or removed after done.

* **Third-Party Libraries:** We carefully choose external libraries to avoid bloat. If a library significantly eases development (like a date handling library or a charts library for activity graphs), we'll use it, but ensure it's well-supported. Each library introduced should be documented (maybe in README) so all devs know what's available. Avoid duplicating functionality (don't use two different HTTP client libs – settle on one; likewise for state management, stick to the chosen approach).

* **Responsive Design:** Though mobile, there are various screen sizes. Use flex layouts and relative sizing when possible. For example, a modal could use `90%` of width on small screens, but maybe fixed max width on tablets. Test on a small phone (e.g. iPhone SE or small Android) vs a large one (Pro Max or similar) to ensure layout scales. Use ScrollView for content that may overflow (like logs) so that on smaller devices nothing is inaccessible.

* **Performance:** Avoid heavy computations on the main thread. Large lists should use FlatList with proper keying to perform well, and perhaps windowing if extremely long (not likely in MVP). Do not freeze the UI with long loops – offload to background if needed or optimize data structures. Use React's memoization (`React.memo` for components, `useMemo`, `useCallback` for expensive calcs or to prevent unnecessary re-renders). Monitor the app using performance tools if you notice any slowness (likely okay given our scale, but e.g., rendering a video feed is heavy so ensure no other unnecessary re-renders happen concurrently).

* **UX Polish:** Follow platform conventions: e.g., on iOS, the swipe-right gesture should go back (React Navigation handles this by default for stack nav). On Android, handling the hardware back button to navigate within the app (React Navigation again covers it, but be mindful of modals). Provide visual feedback for actions: if an owner taps treat, disable the button for a moment and maybe show an animation (like a heart or treat icon flying up) to give a sense of joy and confirmation. Small animations can delight users (without going overboard) – e.g., a subtle bounce when a treat request comes in on admin's side to catch attention, leveraging the Isolation effect in motion as well. Use the **Law of UX** to our advantage: Von Restorff for highlight, Hick's law (don't overwhelm with too many options on one screen, especially for owners – one primary action at a time), etc.

* **Error Handling UX:** If any fetch fails (like loading stream URL), show user-friendly messages ("Unable to connect to camera. Please check back soon.") and possibly auto-retry after some time. For actions the user triggers (like logging in, sending treat), if something goes wrong, inform them ("Request failed, please try again") and allow retry. Always prefer to fail gracefully rather than the app crashing or hanging.

By adhering to these frontend guidelines, the development team can work in parallel confidently, and the resulting app will be consistent in look and feel. The focus is on clear structure, maintainable code, and a delightful user experience that underscores Hetri's innovation while being easy for anyone to use.


